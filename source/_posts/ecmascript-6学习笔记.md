---
title: ECMAScript 6 学习笔记
date: 2017-10-30 17:31:08
categories: javascript
tags: javascript
---

[ECMAScript 6 入门][ECMAScript]读书笔记。
[ECMAScript]: http://es6.ruanyifeng.com/
<!-- more -->

## let 和 const

1. `let` 用来声明变量，`let` 作用域不同于 `var` ,只在它所在的代码块有效。
2. `let` 不会出现变量提升。在代码块内，使用 `let` 命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”
3. 不允许重复声明, `let` 不允许在相同作用域内，重复声明同一个变量。
4. `const` 声明一个只读的常量。一旦声明，常量的值就不能改变。

## 变量的解构赋值

1. 数组的解构赋值
允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（`Destructuring`）。
```javascript
let [a,b,c] = [1,2,3]
```
如果解构不成功，变量的值就等于 `undefined`。
事实上，只要某种数据结构具有 `Iterator` 接口，都可以采用数组形式的解构赋值。

2. 默认值
解构赋值允许指定默认值。
```javascript
let [foo = true] = []
```
内部使用严格相等运算符 `===`，判断一个位置是否有值。所以，如果一个数组成员不严格等于 `undefined`，默认值是不会生效的。

3. 对象的解构赋值
对像的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。
```javascript
let { bar, foo} = {foo: 'aaa', bar: 'bbb'}
```
对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。

4. 字符串的解构赋值
字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。
```javascript
const [a, b, c, d, e] = 'hello'
```

5. 数值和布尔值得解构赋值
解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。
解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。

6. 函数参数的解构赋值
函数的参数也可以使用解构赋值。
```javascript
function add([x, y]){
  return x + y;
}

add([1,2])
```

## 字符串的扩展

1. 字符的 Unicode 表示法
JavaScript 允许采用`\uxxxx`形式表示一个字符，其中`xxxx`表示字符的 Unicode 码点。
但是，这种表示法只限于码点在`\u0000~\uFFFF`之间的字符。超出这个范围的字符，必须用两个双字节的形式表示。
ES6 对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符。
```javascript
'\u{20BB7}'
```

2. codePointAt()
JavaScript 内部，字符以 UTF-16 的格式储存，每个字符固定为`2`个字节。对于那些需要`4`个字节储存的字符（Unicode 码点大于`0xFFFF`的字符），JavaScript 会认为它们是两个字符。
ES6 提供了 `codePoinAt` 方法，能够正确处理4个字节储存的字符，返回一个字符的码点。

3. String.fromCodePoint()
ES6 提供了`String.fromCodePoint`方法，可以识别大于`0xFFFF`的字符，在作用上，正好与`codePointAt`方法相反。

4. 字符串的遍历器接口
ES6 为字符串添加了遍历器接口，使得字符串可以被`for...of`循环遍历。
```javascript
for(let codePoint of 'foo'){
  console.log(codePoint)
}
```
除了遍历字符串，这个遍历器最大的优点是可以识别大于`0xFFFF`的码点，传统的`for`循环无法识别这样的码点。

5. at()
ES5 对字符串对象提供`charAt`方法，返回字符串给定位置的字符。该方法不能识别码点大于`0xFFFF`的字符。
目前，有一个提案，提出字符串实例的at方法，可以识别 Unicode 编号大于0xFFFF的字符，返回正确的字符。

6. normalize()
ES6 提供字符串实例的`normalize()`方法，用来将字符的不同表示方法统一为同样的形式，这称为 Unicode 正规化。

7. includes(),startsWith(),endsWith()
传统上，JavaScript 只有`indexOf`方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6 又提供了三种新方法。
  - includes():返回布尔值，表示是否找到了参数字符串。
  - startsWith():返回布尔值，表示参数字符串是否在原字符串的头部。
  - endsWith():返回布尔值，表示参数字符串是否在原字符串的尾部。
这三个方法都支持第二个参数，表示开始搜索的位置。

8. repeat()
`repeat`方法返回一个新字符串，表示将原字符串重复`n`次。

9. padStart(),padEnd()
ES2017 引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。`padStart()`用于头部补全，`padEnd()`用于尾部补全。
一共接受两个参数，第一个参数用来指定字符串的最小长度，第二个参数是用来补全的字符串。

10. 模板字符串
模板字符串是增强版的字符串，用反引号 (\`) 标识。它可以当做普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。模板字符串中嵌入变量，需要将变量名写在 `${}`之中。

## 正则的扩展
1. RegExp 构造函数
如果 `RegExp` 构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符。而且，返回的正则表达式会忽略原有的正则表达式的修饰符，只使用新指定的修饰符。
```javascript
new RegExp(/abc/ig,'i').flags
```
上面代码中，原有正则对象修饰符时 `ig`,它会被第二个参数 `i` 覆盖。

2. 字符串的正则方法
ES6 将所有与正则相关的方法，全都定义在 `RegExp` 对象上。

3. u 修饰符
ES6 对正则表达式添加了 `u` 修饰符，含义为 `Unicode模式`，用来正确处理大于 `\uFFFF` 的 Unicode 字符。

4. y 修饰符
`y` 修饰符的作用与 `g` 修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，`g` 修饰符只要剩余位置中存在匹配就可，而 `y` 修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。

5. sticky 属性
与 `y` 修饰符相匹配，ES6 的正则对象多了 `sticky` 属性，表示是否设置了 `y` 修饰符。

6. flags 属性
ES6 为正则表达式新增了 `flags` 属性，会返回正则表达式的修饰符。

## 数值的扩展
1. 二进制和八进制表示法
ES6 提供了二进制和八进制数值的新写法，分别用前缀 `0b` （或 `0B`）和 `0o` （或 `0O`）表示。如果要将 `0b` 和 `0o` 前缀的字符串数值转为十进制，要使用 `Number` 方法。
```javascript
Number('0b111') // 7
Number('0o10')  // 8
```

2. Number.isFinite()，Number.isNaN()
`Number.isFinite()` 用来检查一个数值是否为有限的 （finite）。
`Number.isNaN()` 用来检查一个值是否为 `NaN`。