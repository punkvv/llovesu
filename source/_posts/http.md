---
title: HTTP 概述
date: 2017-11-16 15:29:09
categories: HTTP
tags: HTTP
---

超文本传输协议 `HTTP` 是用于传输诸如 `HTML` 的超媒体文档的应用层协议。它被设计用于 Web 浏览器和 Web 服务器之间的通信，但它也可以用于其他目的。HTTP 遵循经典的客户端-服务端模型，客户端打开一个连接以发出请求，然后等待它收到服务端响应。HTTP 是无状态协议，意味着服务器不会在两个请求之间保留任何数据（状态）。

<!-- more -->

## HTTP 概述
HTTP 是一种能够获取如 HTML 这样的网络资源的 `protocol`（通讯协定）。它是 Web 上数据交换的基础，是一种 client-server 协议，也就是说请求通常是由像浏览器这样的接受方发起的。一个完整的 Web 文档是由不同子文档重新组建而成的，像是文本、布局描述、图片、视频、脚本等等。

通常由像浏览器这样的客户端发出的消息叫做 `request`，那么被服务端回应的消息就叫做 `response`。

## 基于 HTTP 的组件系统
在一个浏览器和处理请求的服务器之间，还有许许多多被称为 `proxies` 的实体，还有些是 `caches` 等。还有计算机、路由器、调制解调器等等许多实体，由于 Web 的层次设计，那些在网络层和传输层都不可见了。HTTP 是在最上层应用层中的。

1. 客户端：user-agent
严格意义来说，`user-agent` 就是任何能够为用户发起行为的工具。

2. Web 服务端
在上述通信过程的另一端，就是一个 `Web Server` 来服务并提供客户端请求的文档。Server 只是虚拟意义上：它可以是许多共同分担负载（负载平衡）的一组服务器组成的计算机群，也可以是一种复杂的软件，通过向其他计算机发起请求来获取部分或全部资源的软件。

3. Proxies
在浏览器和服务器之间，有许多计算机和其他设备转发了HTTP的消息。因为 Web 栈层次结构的原因，它们大多数都出现在传输层、网络层和物理层上，对于 HTTP 的应用层来说就是透明的（虽然它们可能会对应用层的性能有重要影响）。而还有一部分表现在应用层上的，就叫做 `proxies` 了。Proxies既可以表现得透明，又可以不透明（看请求是否通过它们），主要表现在这几个功能上：
  - 缓存（可以是公开的或是私有的，像浏览器的缓存）
  - 过滤（像反病毒扫描，家长监护）
  - 负载均衡，让多个服务器服务不同的请求
  - 对不同资源的权限控制
  - 登陆，允许存储历史信息

## HTTP 的基本性质
1. HTTP 是简单的
即便在 HTTP/2 中把 HTTP 消息封装到了 frames 中，HTTP 大体上还是被设计成可读的而且简单的。

2. HTTP 是可扩展的
在HTTP/1中就出现了, `HTTP headers` 让协议扩展变得非常容易。只要服务端和客户端在新的 headers 上语义达成一致，新的功能就可以轻松地被加进来。

3. HTTP 是无状态，有会话的
HTTP 是无状态的：在同一个连接中，两个成功执行的请求之间是没有关系的。这就带来了一个问题，用户没办法在一个网站进行连续的交互，比如在一个电商网站里，用户把某个商品加入了购物车中，换了一个页面后再次添加商品，两次添加商品的请求没有联系，浏览器无法知道最终用户都选择了哪些商品。而用HTTP 的头部扩展，`HTTP Cookies` 就可以解决这个问题。把 Cookies 添加到头部中，创建一个会话来让每次请求都能共享相同的上下文信息，相同的状态。

而 HTTP 的核心是无状态的，cookies 的使用可以创建有状态的会话。

4. HTTP 和连接
一个连接是由传输层来控制的，基本不属于HTTP的范围内。然而HTTP并不需要下面传输层的协议是面向连接的，它只需要它是可靠的，就是说不能丢失消息（至少没有错误）。在因特网两个最常用的传输层协议中，TCP是可靠的，而UDP不是。因此，HTTP依赖于TCP进行消息传递，虽然TCP是面向连接的，但这并不是必须的。

## HTTP 能控制什么

1. 缓存
文档怎么缓存能够通过 HTTP 来控制。服务端能告诉代理和客户端什么需要被缓存，缓存多久，而客户端能够命令中间缓存代理来忽略存储的文档。

2. 开放同源限制
为了防止网络窥听和其它的隐私泄漏，浏览器强制对Web网站做了分割限制。只有来自于相同来源的网页才能够获取网站的全部信息。这样的限制有时反而成了负担，HTTP 可以通过修改头部来开放这样的限制，因此 Web 文档可以是由不同域下的信息拼接成的（在某些情况下，这样做还有安全因素考虑在里面）。

3. 认证
一些页面能够被保护起来，仅让特定的用户进行访问。基本的认证功能可以直接通过HTTP提供，使用 `Authenticate` 相似的头部就可以，或者用 HTTP cookies 来设定指定的会话。

4. 代理和隧道
通常情况下，服务器和/或客户端是处于内网的，对其它（外网）隐藏其真实 IP 地址。因此 HTTP 请求就要通过代理越过这个网络屏障。但并非所有的代理都是 HTTP 代理。例如，SOCKS 协议的代理就运作在更底层。一些像 ftp 其它的协议也能够被它们处理。

5. 会话
`Cookies` 用一个服务端的状态连接起了每一个请求。这就创建了会话，虽然基本的HTTP是无状态协议。这很有用，不仅是因为能用到购物车这样的电商业务上，更是因为，它使得任何网站都能够配置页面展现的东西了。

## HTTP 流

当客户端想要和服务端进行信息交互时，过程表现为下面的几步：

1. 打开一个 TCP 连接（或者重用之前的一个）：TCP 连接用来发送一条或多条请求，当然也用来接受回应消息。客户端可能重用一个已经存在的连接，或者也可能重开几个新的与服务端的 TCP 连接。

2. 发送一个 HTTP 报文：HTTP  报文（在 HTTP/2 之前）是语义可读的。在 HTTP/2 中，这些简单的消息被封装在了帧中，这使得报文不可能被直接读出来，但是规则仍旧是相同的。
```
GET / HTTP/1.1
Host: developer.mozilla.org
Accept-Language: fr
```

3. 读取服务端返回的报文：
```
HTTP/1.1 200 OK
Date: Sat, 09 Oct 2010 14:28:02 GMT
Server: Apache
Last-Modified: Tue, 01 Dec 2009 20:18:22 GMT
ETag: "51142bc1-7449-479b075b2891b"
Accept-Ranges: bytes
Content-Length: 29769
Content-Type: text/html

<!DOCTYPE html... (here comes the 29769 bytes of the requested web page)
```

4. 关闭连接或者为以后的请求重用连接。

## HTTP 报文

HTTP/1.1 和更早的HTTP报文都是语义可读的。在 HTTP/2 中，这些报文被嵌入到了一个新的二进制结构中－帧。帧可以允许实现很多优化，如复用和报文头部的压缩。即使只有原始 HTTP 报文的一部分以这种 HTTP/2 版本的方式发送出来，每个报文的语义依旧不变，客户端会重组原始的 HTTP/1.1 请求。因此用 HTTP/1.1 格式来考虑 HTTP/2 报文仍旧很有效。

有两种 HTTP 报文的类型，请求与回应，每种都有其特定的格式。

1. 请求
请求由下面的元素组成：
<img src="/images/HTTP_Request.png" />
  
  - 一个 HTTP 的 `method`,经常是由一个动词像 `GET`，`POST` 或者一个名词像 `OPTIONS`，`HEAD` 来定义客户端的动作行为的。
  - 要获取的资源的路径，通常是上下文中就很明显的元素资源的 URL，它没有 `protocol` （http://），`domain`（developer.mozilla.org），或是 TCP 的 `port`（HTTP是80端口）。
  - HTTP 协议的版本号。
  - 对于一些像 POST 这样的方法，报文的 body 就包含了发送的资源，这个 body 与回应报文的 body 类似。

2. 回应
回应报文包含了下面的元素：
<img src="/images/HTTP_Response.png" />

  - HTTP 的版本号。
  - 一个状态码（`status code`），来告知对应的请求发送成功或失败，以及失败的原因。
  - 一个状态信息，这个信息是非权威的状态码描述信息，也就是说可以由服务端自行设定的。
  - HTTP headers，与请求的很像。
  - 可选的，但是比在请求报文中更加常见地包含获取资源的 body。
