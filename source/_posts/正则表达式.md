---
title: 正则表达式
date: 2017-11-17 10:54:40
categories: 正则表达式
tags:
  - 正则表达式
---

正则表达式学习

<!-- more -->

正则表达式就是记录文本规则的代码。

## 元字符
正则表达式规定的一个特殊符号，称为 `元字符`。
常用元字符：
1. `.` 匹配除换行符以外的任意字符
2. `\w` 匹配字母或数字或下划线或汉字
3. `\s` 匹配任意空白符
4. `\d` 匹配数字
5. `\b` 匹配单词的开始或结束
6. `^` 匹配字符串的开始
7. `$` 匹配字符串的结束

## 字符转义
使用 `\` 来取消特殊字符的意义。

## 重复
`限定符`用来指定数量，匹配重复的方式。
1. `*` 重复零次或更多次
2. `+` 重复一次或更多次
3. `?` 重复零次或一次
4. `{n}` 重复 n 次
5. `{n,}` 重复 n 次或更多次
6. `{n,m}` 重复 n 到 m 次

## 字符类
把任意字符写在方括号`[]`里，用来匹配没有预定义元字符的字符集合，比如： `[.?!]` 匹配标点符号 (.或?或!)。
也可以指定一个字符范围，`[0-9]` 代表匹配0到9的一位数字。


## 分歧条件
分歧条件指的是有几种规则，如果满足其中任意一种规则都应该当成匹配。
不同的规则之间用符号 `|` 隔开。
匹配分歧条件时，将会从左到右测试每个条件，如果满足了某个分歧的话，就不会去再管其它的条件了。

## 分组
使用 `()` 小括号来指定分组（也被称为`子表达式`）。 如： `(\d{1,3}\.){3}\d{1,3}`,`\d{1,3}`匹配1到3的数字，`(\d{1,3}\.){3}`匹配三位数字加上一个英文句号(这个整体也就是这个`分组`)重复3次，最后再加上一个一到三位的数字`\d{1,3}`。

## 反义
查找与之相反的其它任意字符：
1. `\W` 匹配任意不是字母，数字，下划线，汉字的字符
2. `\S` 匹配任意不是空白字符的字符
3. `\D` 匹配任意非数字的字符
4. `\B` 匹配不是单词开头或结束的位置
5. `[^x]` 匹配除了 x 以外的任意字符
6. `[^aeiou]` 匹配除了 aeiou 这几个字母以外的任意字符

## 后向引用
使用 `()` 小括号指定一个分组后，匹配这个分组的文本可以在表达式或其它程序中作进一步的处理。默认情况下，每个分组会自动拥有一个`组号`,规则是：从左到右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。

`后向引用`用于重复搜索前面某个分组匹配的文本。比如： `\b(\w+)\b\s+\1\b`，`\b(\w+)\b`匹配单词开始处和结束处之间的多于一个的字母或数字，这个单词会被捕获到编号为1的分组中，然后就是`\s+`匹配一个或几个空白字符，最后是`\1`分组1中捕获的内容，也就是前面匹配到的那个单词。

可以指定子表达式的 `组名`。使用这样的语法：`(?<Word>\w+)` 或者 `(?'Word'\w+)`，这样就把`\w+` 的组名指定为 `Word` 了。要方向引用这个分组捕获的内容，可以使用`\k<Word>`。

使用 `()` 小括号的时候，还有很多特定用途的语法，如：
1. `(exp)` 匹配 exp，并捕获文本到自动命名的组里
2. `(?<name>exp)` 匹配 exp，并捕获文本到名称为 name 的组里，也可以写成 `(?\`name\`exp)`
3. `(?:exp)` 匹配 exp，不捕获匹配的文本，也不给此分组匹配组号
4. `(?=exp)` 匹配 exp 前面的位置
5. `(?<=exp)` 匹配 exp 后面的位置
6. `(?!exp)` 匹配后面跟的不是 exp 的位置
7. `(?<!exp)` 匹配前面不是 exp 的位置
8. `(?#comment)` 这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读

## 零宽断言
1. `(?=exp)` `零宽度正预测先行断言`，它断言自身出现的位置的后面能匹配表达式 exp。比如：`\b\w+(?=ing\b)`，匹配以 ing 结尾的单词的前面部分（除了 ing 以外的部分），如查找 `I'm singing while you're dancing.` 时，它会匹配 `sing` 和 `danc`。
2. `(?<=exp)` `零宽度正回顾后发断言`，它断言自身出现的位置的前面能匹配表达式 exp。比如：`(?<=\bre)\w+\b`会匹配以 re 开头的单词的后半部分（除了 re 以外的部分），例如在查找`reading a book`时，它匹配 `ading`。

## 负向零宽断言
1. `(?!exp)` `零宽度负预测先行断言`，它断言此位置的后面不能匹配表达式 exp。例如：`\d{3}(?!\d)`匹配三位数字，而且这三位数字的后面不能是数字。
2. `（?<!exp）` `零宽度负回顾后发断言`，它断言此位置的前面不能匹配表达式 exp。 例如：`(?<![a-z])\d{7}` 匹配前面不是小写字母的七位数字。

## 注释
通过 `(?#comment)` 来包含注释。
如果启用了`忽略模式里的空白符`选项，这样在编写表达式时能任意的添加空格，Tab，换行，而实际使用时这些都将被忽略。启用这个选项后，在#后面到这一行结束的所有文本都将被当成注释忽略掉。
```
(?<=    # 断言要匹配的文本的前缀
<(\w+)> # 查找尖括号括起来的字母或数字(即HTML/XML标签)
)       # 前缀结束
.*      # 匹配任意文本
(?=     # 断言要匹配的文本的后缀
<\/\1>  # 查找尖括号括起来的内容：前面是一个"/"，后面是先前捕获的标签
)       # 后缀结束
```

## 贪婪与懒惰
当正则表达式中包含能接受重复的限定符时，通常的行为是`在使整个表达式能得到匹配的前提下`匹配`尽可能多`的字符。比如：`a.*b`，它会匹配最长的以 a 开始，以 b 结束的字符串。如果用它来搜索 `aabab` 的话，它会匹配整个字符串 aabab。这被称为`贪婪`匹配。

匹配`尽可能少`的字符，就被称为`懒惰`匹配。比如： `a.*?b` 匹配最短的，以 a 开始，以 b 结束的字符串。如果把它应用于 `aabab` 的话，它会匹配 aab（第一到第三个字符） 和 ab（第四到第五个字符）。

懒惰限定符：
1. `*?` 重复任意次，但尽可能少重复
2. `+?` 重复1次或更多次，但尽可能少重复
3. `??` 重复0次或1，但尽可能少重复
4. `{n,m}?` 重复 n 到 m 次，但尽可能少重复
5. `{n,}?` 重复 n 次以上，但尽可能少重复

## 处理选项
使用`选项`来改变处理正则表达式的方式。
如 PHP 中的 [模式修饰符][模式修饰符]

## 平衡组/递归匹配

参考 [正则表达式30分钟入门教程][30]

[30]: http://deerchao.net/tutorials/regex/regex.htm
[模式修饰符]: http://php.net/manual/zh/reference.pcre.pattern.modifiers.php